'use strict';

/**
 * Element selectors for commutes widget.
 */
const commutesEl = {
  map: document.querySelector('.map-view'),
  initialStatePanel: document.querySelector('.commutes-initial-state'),
  destinationPanel: document.querySelector('.commutes-destinations'),
  modal: document.querySelector('.commutes-modal-container'),
};

/**
 * Element selectors for commutes destination panel.
 */
const destinationPanelEl = {
  addButton: commutesEl.destinationPanel.querySelector('.add-button'),
  container: commutesEl.destinationPanel.querySelector('.destinations-container'),
  list: commutesEl.destinationPanel.querySelector('.destination-list'),
  scrollLeftButton: commutesEl.destinationPanel.querySelector('.left-control'),
  scrollRightButton: commutesEl.destinationPanel.querySelector('.right-control'),
  getActiveDestination: () => commutesEl.destinationPanel.querySelector('.destination.active'),
};

/**
 * Element selectors for commutes modal popup.
 */
const destinationModalEl = {
  title: commutesEl.modal.querySelector('h2'),
  form: commutesEl.modal.querySelector('form'),
  destinationInput: commutesEl.modal.querySelector('input[name="destination-address"]'),
  errorMessage: commutesEl.modal.querySelector('.error-message'),
  addButton: commutesEl.modal.querySelector('.add-destination-button'),
  deleteButton: commutesEl.modal.querySelector('.delete-destination-button'),
  editButton: commutesEl.modal.querySelector('.edit-destination-button'),
  cancelButton: commutesEl.modal.querySelector('.cancel-button'),
  getTravelModeInput: () => commutesEl.modal.querySelector('input[name="travel-mode"]:checked'),
};

/**
 * Max number of destination allowed to be added to commutes panel.
 */
const MAX_NUM_DESTINATIONS = 10;

/**
 * Bounds to bias search within ~50km distance.
 */
const BIAS_BOUND_DISTANCE = 0.5;

/**
 * Hour in seconds.
 */
const HOUR_IN_SECONDS = 3600;

/**
 * Minutes in seconds.
 */
const MIN_IN_SECONDS = 60;

/**
 * Stroke colors for destination direction polylines for different states.
 */
const STROKE_COLORS = {
  active: {
    innerStroke: '#4285F4',
    outerStroke: '#185ABC',
  },
  inactive: {
    innerStroke: '#BDC1C6',
    outerStroke: '#80868B',
  },
};

/**
 * Marker icon colors for different states.
 */
const MARKER_ICON_COLORS = {
  active: {
    fill: '#EA4335',
    stroke: '#C5221F',
    label: '#FFF',
  },
  inactive: {
    fill: '#F1F3F4',
    stroke: '#9AA0A6',
    label: '#3C4043',
  },
};

/**
 * List of operations to perform on destinations.
 */
const DestinationOperation = {
  ADD: 'ADD',
  EDIT: 'EDIT',
  DELETE: 'DELETE',
};

/**
 * List of available commutes travel mode.
 */
const TravelMode = {
  DRIVING: 'DRIVING',
//   TRANSIT: 'TRANSIT',
//   BICYCLING: 'BICYCLING',
//   WALKING: 'WALKING',
};

/**
 * Defines instance of Commutes widget to be instantiated when Map library
 * loads.
 */
function Commutes(configuration) {
  let commutesMap;
  let activeDestinationIndex;
  let origin = configuration.mapOptions.center;
  let destinations = configuration.destination || [];
  let markerIndex = 0;
  let lastActiveEl;

  const markerIconConfig = {
    path:
        'M10 27c-.2 0-.2 0-.5-1-.3-.8-.7-2-1.6-3.5-1-1.5-2-2.7-3-3.8-2.2-2.8-3.9-5-3.9-8.8C1 4.9 5 1 10 1s9 4 9 8.9c0 3.9-1.8 6-4 8.8-1 1.2-1.9 2.4-2.8 3.8-1 1.5-1.4 2.7-1.6 3.5-.3 1-.4 1-.6 1Z',
    fillOpacity: 1,
    strokeWeight: 1,
    anchor: new google.maps.Point(15, 29),
    scale: 1.2,
    labelOrigin: new google.maps.Point(10, 9),
  };
  const originMarkerIcon = {
    ...markerIconConfig,
    fillColor: MARKER_ICON_COLORS.active.fill,
    strokeColor: MARKER_ICON_COLORS.active.stroke,
  };
  const destinationMarkerIcon = {
    ...markerIconConfig,
    fillColor: MARKER_ICON_COLORS.inactive.fill,
    strokeColor: MARKER_ICON_COLORS.inactive.stroke,
  };
  const bikeLayer = new google.maps.BicyclingLayer();
  const publicTransitLayer = new google.maps.TransitLayer();

  initMapView();
  initDestinations();
  initCommutesPanel();
  initCommutesModal();

  /**
   * Initializes map view on commutes widget.
   */
  function initMapView() {
    const mapOptionConfig = configuration.mapOptions;
    commutesMap = new google.maps.Map(commutesEl.map, mapOptionConfig);

    configuration.defaultTravelModeEnum =
        parseTravelModeEnum(configuration.defaultTravelMode);
    setTravelModeLayer(configuration.defaultTravelModeEnum);
    createMarker(origin);
  }

  /**
   * Initializes commutes widget with destinations info if provided with a list
   * of initial destinations and update view.
   */
  function initDestinations() {
    if (!configuration.initialDestinations) return;
    let callbackCounter = 0;
    const placesService = new google.maps.places.PlacesService(commutesMap);
    for (const destination of configuration.initialDestinations) {
      destination.travelModeEnum = parseTravelModeEnum(destination.travelMode);
      const label = getNextMarkerLabel();
      const request = {
        placeId: destination.placeId,
        fields: ['place_id', 'geometry', 'name'],
      };
      placesService.getDetails(
          request,
          function(place) {
            if (!place.geometry || !place.geometry.location) return;
            const travelModeEnum =
                destination.travelModeEnum || configuration.defaultTravelModeEnum;
            const destinationConfig =
                createDestinationConfig(place, travelModeEnum, label);
            getDirections(destinationConfig).then((response) => {
              if (!response) return;
              destinations.push(destinationConfig);
              getCommutesInfo(response, destinationConfig);
              callbackCounter++;
              // Update commutes panel and click event objects after getting
              // direction to all destinations.
              if (callbackCounter === configuration.initialDestinations.length) {
                destinations.sort(function(a, b) {
                  return a.label < b.label ? -1 : 1;
                });
                let bounds = new google.maps.LatLngBounds();
                for (let i = 0; i < destinations.length; i++) {
                  assignMapObjectListeners(destinations[i], i);
                  updateCommutesPanel(destinations[i], i, DestinationOperation.ADD);
                  bounds.union(destinations[i].bounds);
                }
                const lastIndex = destinations.length - 1;
                handleRouteClick(destinations[lastIndex], lastIndex);
                commutesMap.fitBounds(bounds);
              }
            });
          },
          () => {
            console.error('Failed to retrieve places info due to ' + e);
          });
    }
  }

  /**
   * Initializes the bottom panel for updating map view and displaying commutes
   * info.
   */
  function initCommutesPanel() {
    const addCommutesButtonEls = document.querySelectorAll('.add-button');
    addCommutesButtonEls.forEach(addButton => {
      addButton.addEventListener('click', () => {
        hideElement(destinationModalEl.deleteButton);
        hideElement(destinationModalEl.editButton);
        showElement(destinationModalEl.addButton);
        showModal();
        const travelModeEnum = configuration.defaultTravelModeEnum || TravelMode.DRIVING;
        const travelModeId = travelModeEnum.toLowerCase() + '-mode';
        document.forms['destination-form'][travelModeId].checked = true;
      });
    });

    destinationPanelEl.scrollLeftButton.addEventListener(
        'click', handleScrollButtonClick);
    destinationPanelEl.scrollRightButton.addEventListener(
        'click', handleScrollButtonClick);
    destinationPanelEl.list.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' &&
          e.target !== destinationPanelEl.getActiveDestination()) {
        e.target.click();
        e.preventDefault();
      }
    });
  }

  /**
   * Initializes commutes modal to gathering destination inputs. Configures the
   * event target listeners to update view and behaviors on the modal.
   */
  function initCommutesModal() {
    const boundConfig = {
      north: origin.lat + BIAS_BOUND_DISTANCE,
      south: origin.lat - BIAS_BOUND_DISTANCE,
      east: origin.lng + BIAS_BOUND_DISTANCE,
      west: origin.lng - BIAS_BOUND_DISTANCE,
    };

    const destinationFormReset = function() {
      //destinationModalEl.destinationInput.classList.remove('error');
      destinationModalEl.errorMessage.innerHTML = '';
      destinationModalEl.form.reset();
      destinationToAdd = null;
    };

    const autocompleteOptions = {
      bounds: boundConfig,
      fields: ['place_id', 'geometry', 'name'],
    };
    const autocomplete = new google.maps.places.Autocomplete(
        destinationModalEl.destinationInput, autocompleteOptions);
    let destinationToAdd;
    autocomplete.addListener('place_changed', () => {
      const place = autocomplete.getPlace();
      if (!place.geometry || !place.geometry.location) {
        return;
      } else {
        destinationToAdd = place;
        destinationModalEl.getTravelModeInput().focus();
      }
      //destinationModalEl.destinationInput.classList.remove('error');
      destinationModalEl.errorMessage.innerHTML = '';
    });

    destinationModalEl.addButton.addEventListener('click', () => {
      const isValidInput = validateDestinationInput(destinationToAdd);
      if (!isValidInput) return;
      const selectedTravelMode = destinationModalEl.getTravelModeInput().value;
      addDestinationToList(destinationToAdd, selectedTravelMode);
      destinationFormReset();
      hideModal();
    });

    destinationModalEl.editButton.addEventListener('click', () => {
      const destination = {...destinations[activeDestinationIndex]};
      const selectedTravelMode = destinationModalEl.getTravelModeInput().value;
      const isSameDestination =
          destination.name === destinationModalEl.destinationInput.value;
      const isSameTravelMode = destination.travelModeEnum === selectedTravelMode;
      if (isSameDestination && isSameTravelMode) {
        hideModal();
        return;
      }
      if (!isSameDestination) {
        const isValidInput = validateDestinationInput(destinationToAdd);
        if (!isValidInput) return;
        destination.name = destinationToAdd.name;
        destination.place_id = destinationToAdd.place_id;
        destination.url = generateMapsUrl(destinationToAdd, selectedTravelMode);
      }
      if (!isSameTravelMode) {
        destination.travelModeEnum = selectedTravelMode;
        destination.url = generateMapsUrl(destination, selectedTravelMode);
      }
      destinationFormReset();
      getDirections(destination)
          .then((response) => {
            if (!response) return;
            const currentIndex = activeDestinationIndex;
            // Remove current active direction before replacing it with updated
            // routes.
            removeDirectionsFromMapView(destination);
            destinations[activeDestinationIndex] = destination;
            getCommutesInfo(response, destination);
            assignMapObjectListeners(destination, activeDestinationIndex);
            updateCommutesPanel(
                destination, activeDestinationIndex, DestinationOperation.EDIT);
            handleRouteClick(destination, activeDestinationIndex);
            const newEditButton = destinationPanelEl.list.children
                .item(activeDestinationIndex)
                .querySelector('.edit-button');
            newEditButton.focus();
          })
          .catch((e) => console.error('Editing directions failed due to ' + e));
      hideModal();
    });

    destinationModalEl.cancelButton.addEventListener('click', () => {
      destinationFormReset();
      hideModal();
    });

    destinationModalEl.deleteButton.addEventListener('click', () => {
      removeDirectionsFromMapView(destinations[activeDestinationIndex]);
      updateCommutesPanel(
          destinations[activeDestinationIndex], activeDestinationIndex,
          DestinationOperation.DELETE);
      activeDestinationIndex = undefined;
      destinationFormReset();
      let elToFocus;
      if (destinations.length) {
        const lastIndex = destinations.length - 1;
        handleRouteClick(destinations[lastIndex], lastIndex);
        elToFocus = destinationPanelEl.getActiveDestination();
      } else {
        elToFocus = commutesEl.initialStatePanel.querySelector('.add-button');
      }
      hideModal(elToFocus);
    });

    window.onmousedown = function(event) {
      if (event.target === commutesEl.modal) {
        destinationFormReset();
        hideModal();
      }
    };

    commutesEl.modal.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'Enter':
          if (e.target === destinationModalEl.cancelButton ||
              e.target === destinationModalEl.deleteButton) {
            return;
          }
          if (destinationModalEl.addButton.style.display !== 'none') {
            destinationModalEl.addButton.click();
          } else if (destinationModalEl.editButton.style.display !== 'none') {
            destinationModalEl.editButton.click();
          }
          break;
        case "Esc":
        case "Escape":
          hideModal();
          break;
        default:
          return;
      }
      e.preventDefault();
    });

    // Trap focus in the modal so that tabbing on the last interactive element
    // focuses on the first, and shift-tabbing on the first interactive element
    // focuses on the last.

    const firstInteractiveElement = destinationModalEl.destinationInput;
    const lastInteractiveElements = [
      destinationModalEl.addButton,
      destinationModalEl.editButton,
    ];

    firstInteractiveElement.addEventListener(
        'keydown', handleFirstInteractiveElementTab);
    for (const el of lastInteractiveElements) {
      el.addEventListener('keydown', handleLastInteractiveElementTab);
    }

    function handleFirstInteractiveElementTab(event) {
      if (event.key === 'Tab' && event.shiftKey) {
        for (const el of lastInteractiveElements) {
          if (el.style.display !== 'none') {
            event.preventDefault();
            el.focus();
            return;
          }
        }
      }
    }

    function handleLastInteractiveElementTab(event) {
      if (event.key === 'Tab' && !event.shiftKey) {
        event.preventDefault();
        firstInteractiveElement.focus();
      }
    }
  }

  /**
   * Checks if destination input is valid and ensure no duplicate places or more
   * than max number places are added.
   */
  function validateDestinationInput(destinationToAdd) {
    let errorMessage;
    let isValidInput = false;
    if (!destinationToAdd) {
      errorMessage = 'No details available for destination input';
    } else if (destinations.length > MAX_NUM_DESTINATIONS) {
      errorMessage =
          'Cannot add more than ' + MAX_NUM_DESTINATIONS + ' destinations';
    } else if (
        destinations &&
        destinations.find(
            destination =>
                destination.place_id === destinationToAdd.place_id)) {
      errorMessage = 'Destination is already added';
    } else {
      isValidInput = true;
    }
    if (!isValidInput) {
      destinationModalEl.errorMessage.innerHTML = errorMessage;
      //destinationModalEl.destinationInput.classList.add('error');
    }
    return isValidInput;
  }

  /**
   * Removes polylines and markers of currently active directions.
   */
  function removeDirectionsFromMapView(destination) {
    destination.polylines.innerStroke.setMap(null);
    destination.polylines.outerStroke.setMap(null);
    destination.marker.setMap(null);
  }

  /**
   * Generates destination card template, attach event target listeners, and
   * adds template to destination list depending on the operations:
   * - add new destination card template to the end of the list on add.
   * - replace destination card template for current selected on edit.
   * - do nothing on default or delete.
   */
  function buildDestinationCardTemplate(
      destination, destinationIdx, destinationOperation) {
    let editButtonEl;
    switch (destinationOperation) {
      case DestinationOperation.ADD:
        destinationPanelEl.list.insertAdjacentHTML(
            'beforeend',
            '<div class="destination-container">' +
                generateDestinationTemplate(destination) + '</div>');
        const destinationContainerEl = destinationPanelEl.list.lastElementChild;
        destinationContainerEl.addEventListener('click', () => {
          handleRouteClick(destination, destinationIdx);
        });
        editButtonEl = destinationContainerEl.querySelector('.edit-button');
        destinationPanelEl.container.scrollLeft =
            destinationPanelEl.container.scrollWidth;
        break;
      case DestinationOperation.EDIT:
        const activeDestinationContainerEl =
            destinationPanelEl.getActiveDestination().parentElement;
        activeDestinationContainerEl.innerHTML = generateDestinationTemplate(destination);
        activeDestinationContainerEl.addEventListener('click', () => {
          handleRouteClick(destination, destinationIdx);
        });
        editButtonEl = activeDestinationContainerEl.querySelector('.edit-button');
        break;
      case DestinationOperation.DELETE:
      default:
    }

    editButtonEl.addEventListener('click', () => {
      destinationModalEl.title.innerHTML = 'Edit destination';
      destinationModalEl.destinationInput.value = destination.name;
      showElement(destinationModalEl.deleteButton);
      showElement(destinationModalEl.editButton);
      hideElement(destinationModalEl.addButton);
      showModal();
      const travelModeId = destination.travelModeEnum.toLowerCase() + '-mode';
      document.forms['destination-form'][travelModeId].checked = true;
      // Update the autocomplete widget as if it was user input.
      destinationModalEl.destinationInput.dispatchEvent(new Event('input'));
    });
  }

  /**
   * Updates view of commutes panel depending on the operation:
   * - build/update destination template if add or edit.
   * - remove destination from destination list and rebuild template.
   */
  function updateCommutesPanel(
      destination, destinationIdx, destinationOperation) {
    switch (destinationOperation) {
      case DestinationOperation.ADD:
        hideElement(commutesEl.initialStatePanel);
        showElement(commutesEl.destinationPanel);
        // fall through
      case DestinationOperation.EDIT:
        buildDestinationCardTemplate(
            destination, destinationIdx, destinationOperation);
        break;
      case DestinationOperation.DELETE:
        destinations.splice(destinationIdx, 1);
        destinationPanelEl.list.innerHTML = '';
        for (let i = 0; i < destinations.length; i++) {
          buildDestinationCardTemplate(
              destinations[i], i, DestinationOperation.ADD);
          assignMapObjectListeners(destinations[i], i);
        }
      default:
    }
    if (!destinations.length) {
      showElement(commutesEl.initialStatePanel, commutesEl.initialStatePanel);
      hideElement(commutesEl.destinationPanel);
      activeDestinationIndex = undefined;
      return;
    }
    destinationPanelEl.container.addEventListener('scroll', handlePanelScroll);
    destinationPanelEl.container.dispatchEvent(new Event('scroll'));
  }

  /**
   * Adds new destination to the list and get directions and commutes info.
   */
  function addDestinationToList(destinationToAdd, travelModeEnum) {
    const destinationConfig =
        createDestinationConfig(destinationToAdd, travelModeEnum);
    const newDestinationIndex = destinations.length;
    getDirections(destinationConfig)
        .then((response) => {
          if (!response) return;
          destinations.push(destinationConfig);
          getCommutesInfo(response, destinationConfig);
          assignMapObjectListeners(destinationConfig, newDestinationIndex);
          updateCommutesPanel(
              destinationConfig, newDestinationIndex, DestinationOperation.ADD);
          handleRouteClick(destinationConfig, newDestinationIndex);
         // destinationPanelEl.addButton.focus();
        })
        .catch((e) => console.error('Adding destination failed due to ' + e));
  }

  /**
   * Returns a new marker label on each call. Marker labels are the capital
   * letters of the alphabet in order.
   */
  function getNextMarkerLabel() {
    const markerLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const label = markerLabels[markerIndex];
    markerIndex = (markerIndex + 1) % markerLabels.length;
    return label;
  }

  /**
   * Creates a destination config object from the given data. The label argument
   * is optional; a new label will be generated if not provided.
   */
  function createDestinationConfig(destinationToAdd, travelModeEnum, label) {
    return {
      name: destinationToAdd.name,
      place_id: destinationToAdd.place_id,
      label: label || getNextMarkerLabel(),
      travelModeEnum: travelModeEnum,
      url: generateMapsUrl(destinationToAdd, travelModeEnum),
    };
  }
  /**
 * Converts latitude and longitude coordinates into a readable address.
 * ...
 */
function getReadableAddress(coordinates, callback) {
    const geocoder = new google.maps.Geocoder();
    const latLng = { lat: coordinates.lat, lng: coordinates.lng };

    geocoder.geocode({ location: latLng }, (results, status) => {
        if (status === google.maps.GeocoderStatus.OK) {
            if (results[0]) {
                callback(null, results[0].formatted_address);
            } else {
                callback('No results found', null);
            }
        } else {
            callback('Geocoder failed due to: ' + status, null);
        }
    });
}

  /**
   * Gets directions to destination from origin, add route to map view, and
   * update commutes panel with distance and directions info.
   */
  function getDirections(destination) {
    const request = {
      origin: origin,
      destination: {'placeId': destination.place_id},
      travelMode: destination.travelModeEnum,
      unitSystem: configuration.distanceMeasurementType === 'METRIC' ?
              google.maps.UnitSystem.METRIC : google.maps.UnitSystem.IMPERIAL,
    };
    const directionsService = new google.maps.DirectionsService();
    return directionsService.route(request).then(response => {
      return response;
    });
  }

  /**
   * Adds route polyline, marker, and commutes info to map and destinations
   * list.
   */
  function getCommutesInfo(directionResponse, destination) {
    if (!directionResponse) return;

    const path = directionResponse.routes[0].overview_path;
    const bounds = directionResponse.routes[0].bounds;
    const directionLeg = directionResponse.routes[0].legs[0];
    const destinationLocation = directionLeg.end_location;
    const distance = directionLeg.distance.text;
    const duration_float = directionLeg.duration.value;
    const duration = convertDurationValueAsString(directionLeg.duration.value);

    const innerStroke = new google.maps.Polyline({
      path: path,
      strokeColor: STROKE_COLORS.inactive.innerStroke,
      strokeOpacity: 1.0,
      strokeWeight: 3,
      zIndex: 10
    });

    const outerStroke = new google.maps.Polyline({
      path: path,
      strokeColor: STROKE_COLORS.inactive.outerStroke,
      strokeOpacity: 1.0,
      strokeWeight: 6,
      zIndex: 1
    });

    const marker = createMarker(destinationLocation, destination.label);

    innerStroke.setMap(commutesMap);
    outerStroke.setMap(commutesMap);

    destination.distance = distance;
    destination.duration = parseInt(duration_float);
    destination.duration_text = duration;
    destination.marker = marker;
    destination.polylines = {innerStroke, outerStroke};
    destination.bounds = bounds;
  }

  /**
   * Assigns event target listeners to map objects of corresponding destination
   * index.
   */
  function assignMapObjectListeners(destination, destinationIdx) {
    google.maps.event.clearListeners(destination.marker, 'click');

    google.maps.event.addListener(destination.marker, 'click', () => {
      handleRouteClick(destination, destinationIdx);
      destinationPanelEl.list.querySelectorAll('.destination')[destinationIdx].focus();
    });
    google.maps.event.addListener(destination.marker, 'mouseover', () => {
      changeMapObjectStrokeWeight(destination, true);
    });
    google.maps.event.addListener(destination.marker, 'mouseout', () => {
      changeMapObjectStrokeWeight(destination, false);
    });
    for (const strokeLine in destination.polylines) {
      google.maps.event.clearListeners(destination.polylines[strokeLine], 'click');
      google.maps.event.clearListeners(destination.polylines[strokeLine], 'mouseover');

      google.maps.event.addListener(destination.polylines[strokeLine], 'click', () => {
        handleRouteClick(destination, destinationIdx);
        destinationPanelEl.list.querySelectorAll('.destination')[destinationIdx].focus();
      });
      google.maps.event.addListener(destination.polylines[strokeLine], 'mouseover', () => {
        changeMapObjectStrokeWeight(destination, true);
      });
      google.maps.event.addListener(destination.polylines[strokeLine], 'mouseout', () => {
        changeMapObjectStrokeWeight(destination, false);
      });
    }
  }

  /**
   * Generates the Google Map url for direction from origin to destination with
   * corresponding travel mode.
   */
  function generateMapsUrl(destination, travelModeEnum) {
    let googleMapsUrl = 'https://www.google.com/maps/dir/?api=1';
    googleMapsUrl += `&origin=${origin.lat},${origin.lng}`;
    googleMapsUrl += '&destination=' + encodeURIComponent(destination.name) +
        '&destination_place_id=' + destination.place_id;
    googleMapsUrl += '&travelmode=' + travelModeEnum.toLowerCase();
    return googleMapsUrl;
  }

  /**
   * Handles changes to destination polyline and map icon stroke weight.
   */
  function changeMapObjectStrokeWeight(destination, mouseOver) {
    const destinationMarkerIcon = destination.marker.icon;
    if (mouseOver) {
      destination.polylines.outerStroke.setOptions({strokeWeight: 8});
      destinationMarkerIcon.strokeWeight = 2;
      destination.marker.setIcon(destinationMarkerIcon);
    }
    else {
      destination.polylines.outerStroke.setOptions({strokeWeight: 6});
      destinationMarkerIcon.strokeWeight = 1;
      destination.marker.setIcon(destinationMarkerIcon);
    }
  }

  /**
   * Handles route clicks. Originally active routes are set to inactive
   * states. Newly selected route's map polyline/marker objects and destination
   * template are assigned active class styling and coloring.
   */
  function handleRouteClick(destination, destinationIdx) {
    if (activeDestinationIndex !== undefined) {
      // Set currently active stroke to inactive
      destinations[activeDestinationIndex].polylines.innerStroke.setOptions(
          {strokeColor: STROKE_COLORS.inactive.innerStroke, zIndex: 2});
      destinations[activeDestinationIndex].polylines.outerStroke.setOptions(
          {strokeColor: STROKE_COLORS.inactive.outerStroke, zIndex: 1});

      // Set current active marker to grey
      destinations[activeDestinationIndex].marker.setIcon(
          destinationMarkerIcon);
      destinations[activeDestinationIndex].marker.label.color =
          MARKER_ICON_COLORS.inactive.label;

      // Remove styling of current active destination.
      const activeDestinationEl = destinationPanelEl.getActiveDestination();
    //   if (activeDestinationEl) {
    //     activeDestinationEl.classList.remove('active');
    //   }
    }

    activeDestinationIndex = destinationIdx;

    setTravelModeLayer(destination.travelModeEnum);
    // Add active class
    const newDestinationEl = destinationPanelEl.list.querySelectorAll(
        '.destination')[destinationIdx];
    newDestinationEl.classList.add('active');
    // Scroll into view
    newDestinationEl.scrollIntoView({behavior: 'smooth', block: 'center'});

    // Make line active
    destination.polylines.innerStroke.setOptions(
        {strokeColor: STROKE_COLORS.active.innerStroke, zIndex: 101});
    destination.polylines.outerStroke.setOptions(
        {strokeColor: STROKE_COLORS.active.outerStroke, zIndex: 99});

    destination.marker.setIcon(originMarkerIcon);
    destination.marker.label.color = '#ffffff';

    commutesMap.fitBounds(destination.bounds);
  }

  /**
   * Generates new marker based on location and label.
   */
  function createMarker(location, label) {
    const isOrigin = label === undefined ? true : false;
    const markerIconConfig = isOrigin ? originMarkerIcon : destinationMarkerIcon;
    const labelColor = isOrigin ? MARKER_ICON_COLORS.active.label :
                                MARKER_ICON_COLORS.inactive.label;
    const labelText = isOrigin ? '‚óè' : label;

    const mapOptions = {
      position: location,
      map: commutesMap,
      label: {
        text: labelText,
        fontFamily: 'Arial, sans-serif',
        color: labelColor,
        fontSize: '16px',
      },
      icon: markerIconConfig
    };

    if (isOrigin) {
      mapOptions.label.className += ' origin-pin-label';
      mapOptions.label.fontSize = '20px';
    }
    const marker = new google.maps.Marker(mapOptions);

    return marker;
  }

  /**
  * Returns a TravelMode enum parsed from the input string, or null if no match is found.
  */
  function parseTravelModeEnum(travelModeString) {
    switch (travelModeString) {
      case 'DRIVING':
        return TravelMode.DRIVING;
      case 'BICYCLING':
        return TravelMode.BICYCLING;
      case 'PUBLIC_TRANSIT':
        return TravelMode.TRANSIT;
      case 'WALKING':
        return TravelMode.WALKING;
      default:
        return null;
    }
  }

  /**
   * Sets map layer depending on the chosen travel mode.
   */
  function setTravelModeLayer(travelModeEnum) {
    switch (travelModeEnum) {
      case TravelMode.BICYCLING:
        publicTransitLayer.setMap(null);
        bikeLayer.setMap(commutesMap);
        break;
      case TravelMode.TRANSIT:
        bikeLayer.setMap(null);
        publicTransitLayer.setMap(commutesMap);
        break;
      default:
        publicTransitLayer.setMap(null);
        bikeLayer.setMap(null);
    }
  }

  /**
   * Convert time from durationValue in seconds into readable string text.
   */
  function convertDurationValueAsString(durationValue) {
    if (!durationValue) {
      return '';
    }
    if (durationValue < MIN_IN_SECONDS) {
      return '<1 min';
    }
    if (durationValue > HOUR_IN_SECONDS * 10) {
      return '10+ hours';
    }
    const hours = Math.floor(durationValue / HOUR_IN_SECONDS);
    const minutes = Math.floor(durationValue % HOUR_IN_SECONDS / 60);
    const hoursString = hours > 0 ? hours + ' h' : '';
    const minutesString = minutes > 0 ? minutes + ' min' : '';
    const spacer = hoursString && minutesString ? ' ' : '';
    return hoursString + spacer + minutesString;
  }

  /**
   * Shows the destination modal window, saving a reference to the currently
   * focused element so that focus can be restored by hideModal().
   */
  function showModal() {
    lastActiveEl = document.activeElement;
    showElement(commutesEl.modal, destinationModalEl.destinationInput);
  }

  /**
   * Hides the destination modal window, setting focus to focusEl if provided.
   * If no argument is passed, focus is restored to where it was when
   * showModal() was called.
   */
  function hideModal(focusEl) {
    hideElement(commutesEl.modal, focusEl || lastActiveEl);
  }
}

/**
 * Hides a DOM element and optionally focuses on focusEl.
 */
function hideElement(el, focusEl) {
  el.style.display = 'none';
  if (focusEl) focusEl.focus();
}

/**
 * Shows a DOM element that has been hidden and optionally focuses on focusEl.
 */
function showElement(el, focusEl) {
  el.style.display = 'flex';
  if (focusEl) focusEl.focus();
}

/**
 * Event handler function for scroll buttons.
 */
function handleScrollButtonClick(e) {
  const multiplier = 1.25;
  const direction = e.target.dataset.direction;
  const cardWidth = destinationPanelEl.list.firstElementChild.offsetWidth;

  destinationPanelEl.container.scrollBy(
      {left: (direction * cardWidth * multiplier), behavior: 'smooth'});
}

/**
 * Event handler on scroll to add scroll buttons only if scroll width is larger
 * than width. Hide scroll buttons if scrolled to the start or end of the panel.
 */
function handlePanelScroll() {
  const position = destinationPanelEl.container.scrollLeft;
  const scrollWidth = destinationPanelEl.container.scrollWidth;
  const width = destinationPanelEl.container.offsetWidth;

  if (scrollWidth > width) {
    if (position === 0) {
      destinationPanelEl.scrollLeftButton.classList.remove('visible');
    } else {
      destinationPanelEl.scrollLeftButton.classList.add('visible');
    }

    if (Math.ceil(position + width) >= scrollWidth) {
      destinationPanelEl.scrollRightButton.classList.remove('visible');
    } else {
      destinationPanelEl.scrollRightButton.classList.add('visible');
    }
  }
}

/**
 * Generates new destination template based on destination info properties.
 */
function generateDestinationTemplate(destination) {
    return `
      <form class="destination-form">
        <div class="destination-content">
          <div class="metadata">
            <label class="form-label">
              Distance:
              <input type="text" name="distance" class="form-control" value="${destination.distance}" readonly>
            </label>
          </div>
          <div class="address">
            <label class="form-label">
              Name:
              <input type="text" name="name" class="form-control" value="${destination.name}" readonly>
            </label>
          </div>
          <div class="destination-eta">
            <label class="form-label">
              Duration:
              <input type="text" name="duration" class="form-control" value="${destination.duration_float}" readonly>
            </label>
          </div>
        </div>
        <div class="destination-controls">
          <button class="edit-button btn btn-outline-primary" type="button" aria-label="Edit Destination">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <use href="#commutes-edit-icon"/>
            </svg>
            Edit
          </button>
          <button class="save-button edit-button d-inline" type="submit" aria-label="Save Destination">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
              <use href="#commutes-save-icon"/>
            </svg>
            Save
          </button>
        </div>
      </form>`;
  }
  



  <!DOCTYPE html>
<html lang="en">
<head>
    <title>Angkas</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="angkas_map.css">

</head>

<body>
    <!-- Defined commutes SVGs -->
    <?php include_once "angkas_map_svg.html";?>
    <!-- End commutes SVGs -->

    <main class="commutes container-fluid">
        <div class="commutes-info row bg-light bg-opacity-75 position-fixed bottom-0 z-3 mb-1">
            <div class="commutes-initial-state border-0">
                <svg aria-label="Directions Icon" width="53" height="53" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <use href="#commutes-initial-icon" />
                </svg>
                <div class="description">
                    <h1 class="heading">Book your EZ Rides</h1>
                    <p>See your Travel Time in Real Time</p>
                </div>
                <button class="add-button btn btn-primary shadow" autofocus>
                    <svg aria-label="Add Icon" width="24px" height="24px" xmlns="http://www.w3.org/2000/svg">
                        <use href="#commutes-add-icon" />
                    </svg>
                    <span class="label">Add destination</span>
                </button>
            </div>

            <div class="commutes-destinations">
                <div class="destinations-container">
                    <div class="destination-list overflow-y-scroll"></div>
                    <button class="add-button d-none">
                        <div class="label">Add destination</div>
                    </button>
                </div>
                <button class="left-control hide" data-direction="-1" aria-label="Scroll left">
                    <svg width="24px" height="24px" xmlns="http://www.w3.org/2000/svg" data-direction="-1">
                        <use href="#commutes-chevron-left-icon" data-direction="-1" />
                    </svg>
                </button>
                <button class="right-control hide" data-direction="1" aria-label="Scroll right">
                    <svg width="24px" height="24px" xmlns="http://www.w3.org/2000/svg" data-direction="1">
                        <use href="#commutes-chevron-right-icon" data-direction="1" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="commutes-map row" aria-label="Map">
            <div class="map-view col-12"></div>
        </div>
    </main>

    <div class="commutes-modal-container shadow">
        <div class="commutes-modal" role="dialog" aria-modal="true" aria-labelledby="add-edit-heading">
            <div class="content bg-purple">
                <h2 id="add-edit-heading" class="heading text-light">Where to Go?</h2>
                <form id="destination-form">
                    <input type="text" id="destination-address-input" class="shadow form-control"
                        name="destination-address" placeholder="Enter a place or address" autocomplete="off" required>
                    <div class="error-message" role="alert"></div>
                    <div class="travel-modes d-none">
                        <input type="radio" name="travel-mode" id="driving-mode" value="DRIVING"
                            aria-label="Driving travel mode">
                        <label for="driving-mode" class="left-label" title="Driving travel mode">
                            <svg aria-label="Driving icon" mlns="http://www.w3.org/2000/svg">
                                <use href="#commutes-driving-icon" />
                            </svg>
                        </label>
                        <!-- <input type="radio" name="travel-mode" id="transit-mode" value="TRANSIT" aria-label="Public transit travel mode">
              <label for="transit-mode" title="Public transit travel mode">
                <svg aria-label="Public transit icon" xmlns="http://www.w3.org/2000/svg">
                  <use href="#commutes-transit-icon"/>
                </svg>
              </label>
              <input type="radio" name="travel-mode" id="bicycling-mode" value="BICYCLING" aria-label="Bicycling travel mode">
              <label for="bicycling-mode" title="Bicycling travel mode">
                <svg aria-label="Bicycling icon" xmlns="http://www.w3.org/2000/svg">
                  <use href="#commutes-bicycling-icon"/>
                </svg>
              </label>
              <input type="radio" name="travel-mode" id="walking-mode" value="WALKING" aria-label="Walking travel mode">
              <label for="walking-mode" class="right-label" title="Walking travel mode">
                <svg aria-label="Walking icon" xmlns="http://www.w3.org/2000/svg">
                  <use href="#commutes-walking-icon"/>
                </svg>
              </label> -->
                    </div>
                </form>
                <div class="modal-action-bar">
                    <button class="delete-destination-button me-1 hide" type="reset">
                        Delete
                    </button>
                    <button class="cancel-button btn btn-outline-secondary me-1" type="reset">
                        Cancel
                    </button>
                    <button class="add-destination-button btn btn-primary me-1" type="button">
                        Add
                    </button>
                    <button class="edit-destination-button hide me-1" type="button">
                        Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="angkas_map.js"></script>

    <script>
    const CONFIGURATION = {
        "defaultTravelMode": "DRIVING",
        "distanceMeasurementType": "METRIC",
        "mapOptions": {
            "fullscreenControl": true,
            "mapTypeControl": false,
            "streetViewControl": false,
            "zoom": 15,
            "zoomControl": true,
            "maxZoom": 20,
            "mapId": ""
        },
        "mapsApiKey": "AIzaSyDB4tE_5d8sQVRR1x2KMTFbQbCpUYWXx8A"
    };

    async function getCurrentLocation() {
        if (!navigator.geolocation) {
            throw new Error("Geolocation is not supported by this browser.");
        }
        return new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const {
                        latitude,
                        longitude
                    } = position.coords;
                    resolve({
                        lat: latitude,
                        lng: longitude
                    });
                },
                (error) => {
                    reject("Geolocation failed. Ensure location services are enabled.");
                }
            );
        });
    }

    async function getReadableAddress(coordinates) {
        const geocoder = new google.maps.Geocoder();
        const latLng = {
            lat: coordinates.lat,
            lng: coordinates.lng
        };

        return new Promise((resolve, reject) => {
            geocoder.geocode({
                location: latLng
            }, (results, status) => {
                if (status === google.maps.GeocoderStatus.OK) {
                    if (results[0]) {
                        resolve({
                            status: 'OK',
                            address: results[0].formatted_address
                        });
                    } else {
                        resolve({
                            status: 'NO_RESULTS',
                            address: null
                        });
                    }
                } else {
                    reject({
                        status: 'FAILED',
                        message: `Geocoder failed due to: ${status}`
                    });
                }
            });
        });
    }

    async function initMap() {

        const currentLocation = await getCurrentLocation();
        console.log("User's Current Location:", currentLocation.lat + ',' + currentLocation.lng);
        const currentAddressTxt = await getReadableAddress(currentLocation);
        console.log("User's Current Address:", currentAddressTxt.address);

        CONFIGURATION.mapOptions.center = currentLocation;
        new Commutes(CONFIGURATION);

    }
    </script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
    </script>
    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDB4tE_5d8sQVRR1x2KMTFbQbCpUYWXx8A&callback=initMap&libraries=maps,places,geometry&solution_channel=GMP_QB_commutes_v3_c&loading=async"
        async defer></script>
</body>

</html>